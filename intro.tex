\section{Introduction}

Most mainstream object-oriented languages provide a notion of equality between objects which can be customized to be weaker than
reference equality, and which is coupled with the customizable notion of object hash code \cite{Bloch18}. Such two notions are provided
through two corresponding methods defined in the predefined class \lstinline{Object} which is at the root of the inheritance hierarchy; hence,
they are inherited or can be redefined in any class, and are callable on any type of object.

For this reason, they are pervasive in object-oriented code and the correct functioning of some features in many libraries rely on them;
hence, their incorrect redefinition or use may have a serious impact on software reliability and safety.

A classical example of useful redefinition of equality is for value classes, where typically a notion of logical equality is needed which differs
from reference equality. 
Obeying the general contract for equality is challenging, and equality redefinition invalidates the general contract for computing
object hash codes \cite{Bloch18}.

Indeed, implementations of hash tables typically use equality and object hash codes, therefore
a general contract has to be satisfied: if two objects are equal,
then the same hash code must be computed for them.

If this requirement is not satisfied, then hash tables fail to behave correctly.
Indeed, to find an element in a hash table, its hash code is computed to identify its bucket, then
equality is used to test whether the element is contained in such a bucket. If an equal element is already contained in the hash table, but in
a different bucket, because the computed hash code is different, then the element cannot be found.

While this problem is well known and there have been some attempts to detect it with verification techniques \cite{Bloch18,OkanoHSON19},
hash code redefinition for mutable classes has been overlooked.
When objects of such classes are used as keys in hash tables, programs may exhibit unexpected and unpredictable behavior. Indeed,
if an object is modified while contained in a hash table, then most likely the same object can no longer be found in the table
even though no operations have been performed on the hash table.

Despite redefinition of equality and hash code in mutable classes is unsafe, many widely used API libraries do that in Java and other similar languages.
Verifying that mutable objects with redefined hash code are used correctly in hash tables is not an easy task, because state modification needs to be tracked with a certain precision and rather complex control-oriented properties \cite{AhrendtCPS17,AnconaDF18} have to be ensured.

In this paper we present a solution based on Runtime Verification (RV), a dynamic verification technique where
a single execution of the system under scrutiny (SUS) is abstracted by an event trace
which is checked by a monitor compiled from the formal specification defining the correct behavior
of the SUS.

Events are usually generated by instrumented code of the SUS, and logged or directly sent to the monitor.
Although specification of properties and code instrumentation can be mixed together, decoupling the two activities favors abstraction, reuse and
interoperability of the generated monitors.

Monitors can be \emph{offline} or \emph{online};
in offline RV a trace is typically generated by the instrumented SUS and stored into a log file and then is analyzed by the monitor.
In online RV traces are analyzed real-time to allow error detection to trigger specific actions on the SUS. 
Offline RV \cite{Colombo2022} is a useful solution to integrate other approaches as debugging and testing;  %when errors are not critical or online RV would be too costly;
online RV can be employed to allow error recovery in critical scenarios, providing that such a choice is compatible with the overhead of code instrumentation and of the monitor execution. 

RV is complementary to formal verification and testing:
as formal verification, RV is based on a specification formalism; as happens for software testing, it
scales well to real systems and complex properties, but cannot guarantee exhaustiveness.
Differently from testing, it is particularly useful to ensure control-oriented properties \cite{AhrendtCPS17,AnconaDF18} 
and detect errors due to non-deterministic behavior \cite{havelund2004,sharma2009}.
Furthermore, online monitoring allows runtime contract enforcement, fault protection and automatic program repair.
Finally, several RV tools are based on abstract and intuitive specification languages that can be easily mastered by the user
and favor system agnosticism, portability, reuse, and interoperability.

Our proposed solution is based on offline RV and uses  \rml\footnote{\href{https://rmlatdibris.github.io/}{https://rmlatdibris.github.io/}.}, a rewriting-based Domain Specific Language (DSL) for RV
which allows definition of formal specifications independently of code instrumentation and of the programming language used
to develop the software to be verified. The choice of \rml makes our solution easily portable to different Java-like languages.
Offline RV has been preferred over online RV because the main aim is to detect unsafe use of hash tables; this allows also a simpler solution
which minimize overhead.

The paper is structured as follows.
\Cref{sec:example} introduces the problem in detail and analyzes it in the context of several mainstream object-oriented languages,
\Cref{sec:rml} provides an introduction to \rml, \Cref{sec:spec} presents the proposed solution and discussed possible generalization,
\Cref{sec:rel-concl} is devoted to the related work and conclusions.
