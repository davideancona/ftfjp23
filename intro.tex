\section{Introduction}

Most mainstream object-oriented languages provide a notion of equality between objects which can be customized to be weaker than
reference equality, and which is coupled with the customizable notion of object hash code \cite{Bloch18}. Such two notions are provided
through two corresponding methods defined in the predefined class \lstinline{Object} class which is a the root of the inheritance hierarchy; hence,
they are inherited or redefined in any class, and callable on any type of object.

For this reason, they are pervasive in object-oriented code and the correct functioning of some functionalities of many libraries rely on them;
hence, their incorrect redefinition or use may have a serious impact on software reliability and safety.

A classical example of useful redefinition of equality is for value classes, where typically a notion of logical equality is needed which differs
from reference equality \cite{Bloch18}. 
Obeying the general contract for equality is challenging, and equality redefinition invalidates the general contract for computing
object hash codes.

Indeed, implementations of hash tables typically use equality and object hash codes, therefore
they have to satisfy the general contract requiring that if two objects are equal,
then the same hash code must be computed for them. If this requirement is not satisfied, then hash tables fail to behave correctly.
Indeed, to find an element in a hash table, its hash code is computed to identify its bucket, then
equality is used to test whether the element is contained in such a bucket. If an equal element is already contained in the hash table, but in
a different bucket, because the computed hash code is different, then the element cannot be found.

While this problem is well known and there have been some attempts to detect it with verification techniques \cite{Bloch18,OkanoHSON19},
the similar problem of hash code redefinition for mutable classes has been overlooked.
Despite mutable classes should not redefine equality and hash code, many widely used API libraries do that in Java and other similar languages.
When objects of such classes are used as keys in hash tables, programs may exhibit unexpected and unpredictable behavior. Indeed,
if an object is modified while contained in a hash table, then most likely the same object can no longer be found in the table
even though no operations have been performed on the hash table.

Verifying that mutable objects with redefined hash code are used correctly in hash tables is not an easy task, because state modification needs to be tracked with a certain precision and rather complex control-oriented properties \cite{AhrendtCPS17} have to be ensured.

In this paper we present a solution based on Runtime Verification (RV), a dynamic verification technique where
the event trace generated by a single run of
the system under scrutiny (SUS) is checked by a monitor compiled from the formal specification which defines the correct behavior
of the SUS.
Events are usually emitted through code instrumentation of the SUS, to allow monitors to observe them;
although specification of properties and code instrumentation can be mixed together, decoupling the two activities favors abstraction, reuse and
interoperability of the generated monitors.

Monitors can be run \emph{offline} or \emph{online};
in offline RV monitors analyze event traces  after that they have been generated and collected into log files
by the instrumented SUS. In online RV traces are analyzed real-time to allow error detection to trigger specific actions on the SUS. 
Offline RV \cite{Colombo2022} is often exploited as a useful solution to integrate other approaches as debugging and testing;  %when errors are not critical or online RV would be too costly;
when the overhead of code instrumentation and of the executed monitors is limited, online RV can be employed to allow error recovery in critical scenarios. 

RV is complementary to formal verification and testing:
as formal verification, RV is based on a specification formalism; as happens for software testing, it
scales well to real systems and complex properties, but cannot guarantee exhaustiveness.
Differently from testing, it is particularly useful to ensure control-oriented properties 
and detect errors due to non-deterministic behavior \cite{havelund2004,sharma2009}.
Furthermore, online monitoring allows runtime contract enforcement, fault protection and automatic program repair.
Finally, several RV tools are based on abstract and intuitive specification languages that can be easily mastered by the user
and favor system agnosticism, portability, reuse, and interoperability.

Our proposed solution uses \rml\footnote{\href{https://rmlatdibris.github.io/}{https://rmlatdibris.github.io/}.}, a rewriting-based Domain Specific Language (DSL) for RV
which allows definition of formal specifications independently of code instrumentation and of the programming language used
to develop the software to be verified. 

The paper is structured as follows.
\Cref{sec:example} introduces the problem in detail and analyzes it in the context of several mainstream object-oriented languages,
\Cref{sec:rml} provides an introduction to \rml, \Cref{sec:spec} presents the proposed solution and discussed possible generalization,
\Cref{sec:rel-concl} is devoted to the related work and conclusions.
