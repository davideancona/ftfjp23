\section{\rml}
\label{sec:rml}
\lstset{morekeywords={matches,not,let}}
\rml\cite{RML2021} is a rewriting-based DSL for RV which allows developers to define formal specifications independently of code instrumentation.

It  is based on the notion of \emph{event type} (denoting a set of events) and \emph{trace expression} (denoting a set of event traces),
and it is implemented by a compiler, which generates monitors able to run independently of the SUS and of its instrumentation. 
%The language is based on previous work on RV and global types \cite{CastagnaEtAl12,AnconaBB0CDGGGH16,AnconaFM17},
%applied to several contexts, including verification of interaction protocols in multi-agent systems \cite{AnconaDM12,AnconaBFMT14, BriolaMA14}.

\paragraph{Events}
In \rml an \emph{event} is any observation relevant for monitoring the SUS.
Events are represented in a general way with object literals and
consist of properties which identify the type of event and the data associated with it. For instance,

\begin{lstlisting}
{event:"func_post",targetId:9,name:"add",
    res:true,args:[1]}
\end{lstlisting}          
represents the event
`call to method \lstinline{add} on target object with id 9 and with argument 1  has returned value \lstinline{true}.
Another type of events which are often useful to monitor is \lstinline{'func_pre'}, that is, entering a constructor or method call; of course, in this
case, no information on the returned value can be provided. Depending on the features of the instrumentation tool, other finer grained types,
as reading or updating a field, can be used, but at the cost of making specifications more coupled with the specific application that needs to be
verified, and, hence, less reusable and portable.

An \rml specification defines the set of event traces expected from correct runs of the SUS; the monitor automatically generated from
such a specification checks that the trace generated by a single run of the SUS belongs to such a set.

\paragraph{Event Types}
The basic blocks which constitute an \rml specification are \emph{patterns} built from
\emph{event types} defining sets of events.

Event types are defined with clauses:
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
add(hash_id,elem_id) matches {event:'func_post', targetId:hash_id, name:'add', argIds:[elem_id], res:true};
\end{lstlisting}
In this example \lstinline{add} matches events parametric in the
ids \lstinline{hash_id} and \lstinline{elem_id} of the target and argument of the call. While property
\lstinline{args} is useful when arguments are primitive values, \lstinline{argIds} is used when arguments are objects, denoted by their unique id;
similarly, for the returned value the two properties \lstinline{res} and \lstinline{resultId} are available.

%% As a more general example
%% \begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
%% modify(id) matches {event:'func_post', targetId:id, name:'add' | 'addAll' | 'remove' | 'removeAll' | 'removeIf' | 'retainAll', argIds:[_], res:true};
%% \end{lstlisting}
%% defines the event type matching all calls on target with object identifier id which modify it. 

%\noindent then $\mtch(\ev,\mathit{open}(x))$ successfully returns the substitution
%$\{ x \mapsto 42 \}$.

%%Trace expressions have been extended with variables in \cite{AnconaFM17}.

\rml allows also the definition of event types derived from others:

\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
not_add(hash_id) not matches add(hash_id,_);
op(hash_id,elem_id) matches {targetId:hash_id} | {targetId:elem_id};
\end{lstlisting}  
The event pattern \lstinline{not_add(hash_id)} matches all events which do not correspond to the return from
method \lstinline{add} called on target \lstinline{hash_id}; the wildcard \lstinline!_! is used when a value is not relevant for
the definition of the event type.

The event pattern \lstinline{op(hash_id,elem_id)} matches all events matching either \lstinline!{targetId:hash_id}! or
\lstinline!{targetId:elem_id}!, that is, all calls on target \lstinline{hash_id} or \lstinline{elem_id}.

\paragraph{Trace Expressions}
The basic layer of \rml are expressions that define sets of event traces and built by combining together event patterns with primitive and derived operators.
The former kind of operators includes, among others, the following binary operators on sets of event traces:
\begin{itemize}
	%% \item $\emptyseq$ (\emph{empty trace}): the singleton set $\{\emptyseq\}$ containing  the empty event trace $\emptyseq$;
	%% \item $\eventTy\prefixop\tau$ (\emph{prefix}): the set of all traces whose first event $\ev$ matches the event type $\eventTy$, and the remaining part is a trace of $\tau$;
	\item \emph{concatenation} (denoted by juxtaposition);
	\item \emph{intersection} \lstinline{/\};
	\item \emph{union} \lstinline{\/}; 
	\item \emph{shuffle} \lstinline{|}. 
	%% \item $\var{x}{\tau}$ (\emph{binder}): it binds the free occurrences of $\xv$ in $\tau$;
	%% \item $\eventTy\filterop\tau$ (\emph{filter}):
	%% denoting the set of all traces contained in $\tau$, when they are deprived af all events that do not match $\eventTy$ (theoretically, this operator can also be derived from the others).
\end{itemize}
Other useful derivable operators are available, including the standard postfix operators
\lstinline{?}, \lstinline{+} and \lstinline{*}, borrowed from regular expressions,  the constant \lstinline{all}, which denotes the universe of all traces,
and the  conditional filter operator \lstinline{_ >> _ : _}.
%% which denotes the set of all
%% traces verifying $\te_1$ when only the events matching $\eventTy$ are kept, and
%% $\te_2$ when the events matching $\eventTy$ are filtered out.

%Trace expressions are regular terms (a.k.a. cyclic) \cite{Courcelle83}, thus there is no need for an explicit recursion operator.
The formal semantics of trace expressions is defined in terms of a labeled transition system \cite{RML2021}.

As a very simple example, the specification \lstinline{Main} in \Cref{example} defines the set of event traces starting with a call to
a constructor of class \lstinline{HashSet} returning the object id 42, followed by zero or more calls to method \lstinline{add} on target id 42 with returned value \lstinline{true} and ending with a call to method \lstinline{remove} on the same target id with returned value \lstinline{true}.
%% The fact that the specification ends with \lstinline{all} means that after the event matching \lstinline{remove(42)} any event trace is allowed, that is, no further verification is required.

\begin{figure}[h]
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
new_hash(hash_id) matches {event:'func_post', name:'HashSet', resultId:hash_id};
remove(hash_id) matches {event:'func_post', targetId:hash_id, name:'remove', res:true};
add(hash_id) matches {event:'func_post', targetId:hash_id, name:'add', res:true};

Main = new_hash(42) add(42)* remove(42);
\end{lstlisting}
\caption{Example of specification.}\label{example}
\end{figure}

\paragraph{Parametric Specifications}
The expression \lstinline{new_hash(42) add(42)* remove(42)} is of very limited use because it refers to a specific object id;
however, \rml provides a \lstinline{let} construct \cite{AnconaFM17} for declaring existentially quantified variables.
With such an abstraction and the shuffle operator, it is possible to write a \emph{parametric} specification working for any instance of class \lstinline{HashSet}:
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
Main = {let hash_id; new_hash(hash_id) (add(hash_id)* remove(hash_id) | Main)};
\end{lstlisting}
When the first event matches \lstinline{new_hash(hash_id)}, \lstinline{hash_id} is bound to the specific id returned by the constructor in the two
occurences on the left-hand-side of the shuffle. The binding does not affect the recursive use of \lstinline{Main}
because its nested \lstinline{let} declaration masks the outer one, thus allowing to properly verify the specified property
for any new instance of the class.

It is worth noting that such a specification pattern where recursion occurs on one side of shuffle (or intersection, as shown in the next section)
is quite useful for specifying several kinds of properties \cite{RML2021} which cannot be specified with regular expressions (and hence
with LTL which is less expressive \cite{Strejcek2004}). Indeed, while regular expressions are closed w.r.t. shuffle, they are not
w.r.t. iterated shuffle \cite{FlickK12}; intersection allows even more expressive power since context-free languages are not closed w.r.t. such an operation \cite{RML2021}.

%% At this point the shuffle operator is crucial\footnote{In order for the shuffle to work, we assume that every \(\opent\) operation always gives a fresh file descriptor, which can be reasonably assumed to be ensured by the operating system.}: following events are allowed to belong either to \(\tau\) (operations on new files, in the correct order) or to \(\tau'\{\avar{fd}\mapsto x\}\) (note the substitution!) were further operations on \(x\) will be checked.

\paragraph{Generic Specifications}
\rml provides a further abstract layer with \emph{generic} specifications,
to enhance modularity and reuse and increase its expressive power \cite{RML2021}.
%%offer more opportunities for reuse and increase the expressive power of \rml with the conditional expression.
With the generic \lstinline{Spec<hash_id>}, the specification above
can be generalized as follows to make it more readable and possibly reusable:
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
Spec<hash_id> =  add(hash_id)* remove(hash_id); 
Main = {let hash_id; new_hash(hash_id) ( Spec<hash_id> | Main)};
\end{lstlisting}
%% To modify the specification of the allowed traces after the creation of an \lstinline{HashSet} instance, only the definition
%% \lstinline{File<fdesc>} needs to be redefined:
%% \begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
%% ...
%% chmod(fd) matches {event:'func_pre', name:'fs.fchmodSync', args:[fd,_]};

%% File<fdesc> = chmod(fdesc)? write(fdesc)* close(fdesc); // chmod allowed but only before writing
%% Main = {let fdesc; open(fdesc) (File<fdesc>  | Main)}; // Main specification unchanged
%% \end{lstlisting}
%% Recursion together with the conditional expression are used to define more expressive generic specifications:
%% \begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
%% Repeat<n> = if (n>0) eventType Repeat<n-1> else empty;
%% \end{lstlisting}
%% The generic specification \lstinline{Repeat<$n$>} defines all traces of length $n$ where all events match
%% the event type pattern \lstinline{eventType}.
