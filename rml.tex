\section{\rml}
\label{sec:rml}
\rml\cite{RML2021} is a rewriting-based DSL for RV which allows developers to define formal specifications independently of code instrumentation.

It  is based on the notion of \emph{event type} (denoting a set of events) and \emph{trace expression} (denoting a set of event traces),
and it is implemented by a compiler, which generates monitors able to run independently of the SUS and of its instrumentation. 
%The language is based on previous work on RV and global types \cite{CastagnaEtAl12,AnconaBB0CDGGGH16,AnconaFM17},
%applied to several contexts, including verification of interaction protocols in multi-agent systems \cite{AnconaDM12,AnconaBFMT14, BriolaMA14}.

\paragraph{Events}
In \rml an \emph{event} is any observation relevant for monitoring the SUS.
Events are represented in a general way with object literals and
consist of properties which identify the type of event and the data associated with it. For instance,

\begin{lstlisting}
{event:"func_post",targetId:9,name:"add",
    res:true,args:[1]}
\end{lstlisting}          
represents the event
`call to method \lstinline{add} on target object with id 9 and with argument 1  has returned value \lstinline{true}.

An \rml specification defines the set of event traces expected from correct runs of the SUS; the monitor automatically generated from
such a specification checks that the trace generated by a single run of the SUS belongs to such a set.

\paragraph{Event Types}
The basic blocks which constitute an \rml specification are \emph{patterns} built from
\emph{event types} defining sets of events.

Event types are defined with clauses as the following one
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
add(id) matches {event:'func_post', targetId:id, name:'add', argIds:[_], res:true};
\end{lstlisting}
The wildcard \lstinline!_! is used when a value is not relevant for
the definition of the event type; in this case \lstinline{add} has to match the
id of the target and the returned result, but not the passed argument.

As a more general example
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
modify(id) matches {event:'func_post', targetId:id, name:'add' | 'addAll' | 'remove' | 'removeAll' | 'removeIf' | 'retainAll', argIds:[_], res:true};
\end{lstlisting}
defines the event type matching all calls on target with object identifier id which modify it. 

%\noindent then $\mtch(\ev,\mathit{open}(x))$ successfully returns the substitution
%$\{ x \mapsto 42 \}$.

%%Trace expressions have been extended with variables in \cite{AnconaFM17}.

\rml allows also the definition of event types derived from others, through\footnote{For simplicity, in definitions of derived event types the current implementation of \rml supports only the `not' and `or' operators.} the `or' and `not' operators:
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
file_op(fd) matches write(fd) | read(fd);
not_open not matches open(_);
\end{lstlisting}  
The event type pattern \lstinline{file_op(fd)} matches all events corresponding to read or write operations on a file descriptor \lstinline{fd}, and can
be directly derived from the event type patterns \lstinline{write(fd)} and \lstinline{read(fd)}, while \lstinline{not_open} matches all
events not matching \lstinline{open(fd)} for some \lstinline{fd}.

\paragraph{Trace Expressions}
Constitute the basic layer of \rml for defining specifications.
they can be built by combining together event type patterns with primitive and derived operators.
The former kind of operators includes the constant \lstinline{empty}, denoting the singleton set
with the empty trace, the unary postfix operator \lstinline{!} for prefix closure, and the following binary operators:
\begin{itemize}
	%% \item $\emptyseq$ (\emph{empty trace}): the singleton set $\{\emptyseq\}$ containing  the empty event trace $\emptyseq$;
	%% \item $\eventTy\prefixop\tau$ (\emph{prefix}): the set of all traces whose first event $\ev$ matches the event type $\eventTy$, and the remaining part is a trace of $\tau$;
	\item \emph{concatenation} (denoted by juxtaposition) to express sequentiality;
	\item \emph{intersection} \lstinline{/\} for simultaneous verification of multiple properties;
	\item \emph{union} \lstinline{\/} for defining alternatives; 
	\item \emph{shuffle} \lstinline{|} to allow interleaving of events in traces. 
	%% \item $\var{x}{\tau}$ (\emph{binder}): it binds the free occurrences of $\xv$ in $\tau$;
	%% \item $\eventTy\filterop\tau$ (\emph{filter}):
	%% denoting the set of all traces contained in $\tau$, when they are deprived af all events that do not match $\eventTy$ (theoretically, this operator can also be derived from the others).
\end{itemize}
Since trace expressions can be defined recursively, several useful operators can be derived, including the standard postfix operators
\lstinline{?}, \lstinline{+} and \lstinline{*}, borrowed from regular expressions,  the constant \lstinline{all}, which denotes the universe of all traces,
and the  conditional filter operator \lstinline{_ >> _ : _}.
%% which denotes the set of all
%% traces verifying $\te_1$ when only the events matching $\eventTy$ are kept, and
%% $\te_2$ when the events matching $\eventTy$ are filtered out.

%Trace expressions are regular terms (a.k.a. cyclic) \cite{Courcelle83}, thus there is no need for an explicit recursion operator.

For instance, the following simple specification \lstinline{Main} defines a correct usage of a writable file:
\begin{figure}[h]
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
open(fd) matches {event:'func_post', name:'fs.openSync', args:[_,'w',...], res:fd};
write(fd) matches {event:'func_pre', name:'fs.writeSync', args:[fd,...]};
close(fd) matches {event:'func_pre', name:'fs.closeSync', args:[fd]};

Main = open(fdesc) write(fdesc)* close(fdesc);
\end{lstlisting}
\caption{Specification of synchronous file operations.}\label{list:sync-fs}
\end{figure}
The specified traces must begin with an event matching the event type pattern \lstinline{open(fdesc)}, that is,
a call to \lstinline{fs.openSync} with returned value matching \lstinline{fdesc}, continue with a possibly empty sequence of events matching
\lstinline{write(fdesc)}, that is, calls\footnote{Events of type  \lstinline{'func_pre'}
correspond to calls to functions that have not returned yet.} to function \lstinline{fs.writeSync} with the first argument matching the same value \lstinline{fdesc}
returned by \lstinline{fs.openSync}, and, finally, must terminate with a call
to function \lstinline{fs.closeSync} with argument matching \lstinline{fdesc} again.

%% Not all operators will be used in this document, but they all can be useful in different contexts.
%% See \cite{ancona2016comparing} for a complete technical presentation of trace expressions with more examples. 

\paragraph{Parametric Specifications}
The expression \lstinline{open(fdesc) write(fdesc)* close(fdesc)} can only verify the correct use of a single file;
the parametric layer of \rml provides a \lstinline{let} construct \cite{AnconaFM17} for declaring variables and delimiting their scope,
to control their dynamic instantiation through event matching.
With such an abstraction and the shuffle operator, it is possible to write a \emph{parametric} specification
for monitoring the access to an arbitrary number of files:
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
Main = {let fdesc; open(fdesc) (write(fdesc)* close(fdesc)  | Main)};
\end{lstlisting}
When the first event matches \lstinline{open(fdesc)}, a substitution for variable 
\lstinline{fdesc} is computed, depending from the returned value of \lstinline{fs.openSync}, and such a substitution is applied
to the rest of the specification.
In this way, the two occurrences of \lstinline{fdesc} on the left operand of the shuffle are correctly
instantiated, while the substitution does not affect the right operand, consisting of the recursive
use of \lstinline{Main}, because the nested \lstinline{let} construct allows the declaration of fresh
variables to mask the previously instantiated variables. As a consequence, the
next call to \lstinline{fs.openSync} is allowed to pass a different file name and return a
different file descriptor, because the corresponding event type pattern \lstinline{open(fdesc)}
is not instantiated yet.

%% At this point the shuffle operator is crucial\footnote{In order for the shuffle to work, we assume that every \(\opent\) operation always gives a fresh file descriptor, which can be reasonably assumed to be ensured by the operating system.}: following events are allowed to belong either to \(\tau\) (operations on new files, in the correct order) or to \(\tau'\{\avar{fd}\mapsto x\}\) (note the substitution!) were further operations on \(x\) will be checked.

\paragraph{Generic Specifications}
The most abstract layer of \rml provides support for \emph{generic} specifications,
which enhance modularity, offer more opportunities for reuse and increase the expressive power of \rml with the conditional expression.
For instance, the specification \lstinline{Main} defined above
can be generalized as follows to make it reusable in other specifications:
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
File<fdesc> = write(fdesc)* close(fdesc); // only write allowed before closing 
Main = {let fdesc; open(fdesc) (File<fdesc>  | Main)};
\end{lstlisting}
If one would like to change the specification of the allowed operations on the files to be monitored, then only the definition
of the parametric specification \lstinline{File<fdesc>} needs to be redefined:
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
...
chmod(fd) matches {event:'func_pre', name:'fs.fchmodSync', args:[fd,_]};

File<fdesc> = chmod(fdesc)? write(fdesc)* close(fdesc); // chmod allowed but only before writing
Main = {let fdesc; open(fdesc) (File<fdesc>  | Main)}; // Main specification unchanged
\end{lstlisting}
Recursion together with the conditional expression are used to define more expressive generic specifications:
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
Repeat<n> = if (n>0) eventType Repeat<n-1> else empty;
\end{lstlisting}
The generic specification \lstinline{Repeat<$n$>} defines all traces of length $n$ where all events match
the event type pattern \lstinline{eventType}.
