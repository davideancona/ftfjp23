\section{\rml}
\label{sec:rml}
\rml\cite{RML2021} is a rewriting-based DSL for RV which allows developers to define formal specifications independently of code instrumentation.

It  is based on the notion of \emph{event type} (denoting a set of events) and \emph{trace expression} (denoting a set of event traces),
and it is implemented by a compiler, which generates monitors able to run independently of the SUS and of its instrumentation. 
%The language is based on previous work on RV and global types \cite{CastagnaEtAl12,AnconaBB0CDGGGH16,AnconaFM17},
%applied to several contexts, including verification of interaction protocols in multi-agent systems \cite{AnconaDM12,AnconaBFMT14, BriolaMA14}.

\paragraph{Events}
In \rml an \emph{event} is any observation relevant for monitoring the SUS.
Events are represented in a general way with object literals and
consist of properties which identify the type of event and the data associated with it. For instance,

\begin{lstlisting}
{event:"func_post",targetId:9,name:"add",
    res:true,args:[1]}
\end{lstlisting}          
represents the event
`call to method \lstinline{add} on target object with id 9 and with argument 1  has returned value \lstinline{true}.

An \rml specification defines the set of event traces expected from correct runs of the SUS; the monitor automatically generated from
such a specification checks that the trace generated by a single run of the SUS belongs to such a set.

\paragraph{Event Types}
The basic blocks which constitute an \rml specification are \emph{patterns} built from
\emph{event types} defining sets of events.

Event types are defined with clauses:
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
add(hash_id,elem_id) matches {event:'func_post', targetId:hash_id, name:'add', argIds:[elem_id], res:true};
\end{lstlisting}
In this example \lstinline{add} matches events parametric in the
ids \lstinline{hash_id} and \lstinline{elem_id} of the target and argument of the call. While property
\lstinline{args} is useful when arguments are primitive values, \lstinline{argIds} is used when arguments are objects, denoted by their unique id;
similarly, for the returned value the two properties \lstinline{res} and \lstinline{resultId} are available.

%% As a more general example
%% \begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
%% modify(id) matches {event:'func_post', targetId:id, name:'add' | 'addAll' | 'remove' | 'removeAll' | 'removeIf' | 'retainAll', argIds:[_], res:true};
%% \end{lstlisting}
%% defines the event type matching all calls on target with object identifier id which modify it. 

%\noindent then $\mtch(\ev,\mathit{open}(x))$ successfully returns the substitution
%$\{ x \mapsto 42 \}$.

%%Trace expressions have been extended with variables in \cite{AnconaFM17}.

\rml allows also the definition of event types derived from others:

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
not_add(hash_id) not matches add(hash_id,_);
op(hash_id,elem_id) matches {targetId:hash_id} | {targetId:elem_id};
\end{lstlisting}  
The event type pattern \lstinline{not_add(hash_id)} matches all events which do not correspond to the return from
method \lstinline{add} called on target \lstinline{hash_id}; the wildcard \lstinline!_! is used when a value is not relevant for
the definition of the event type.

The event type pattern \lstinline{op(hash_id,elem_id)} matches all events matching either \lstinline!{targetId:hash_id}! or
\lstinline!{targetId:elem_id}!, that is, all calls on target \lstinline{hash_id} or \lstinline{elem_id}.

\paragraph{Trace Expressions}
The basic layer of \rml are expressions that define sets of event traces and built by combining together event type patterns with primitive and derived operators.
The former kind of operators includes, among others, the following binary operators on sets of event traces:
\begin{itemize}
	%% \item $\emptyseq$ (\emph{empty trace}): the singleton set $\{\emptyseq\}$ containing  the empty event trace $\emptyseq$;
	%% \item $\eventTy\prefixop\tau$ (\emph{prefix}): the set of all traces whose first event $\ev$ matches the event type $\eventTy$, and the remaining part is a trace of $\tau$;
	\item \emph{concatenation} (denoted by juxtaposition);
	\item \emph{intersection} \lstinline{/\};
	\item \emph{union} \lstinline{\/}; 
	\item \emph{shuffle} \lstinline{|}. 
	%% \item $\var{x}{\tau}$ (\emph{binder}): it binds the free occurrences of $\xv$ in $\tau$;
	%% \item $\eventTy\filterop\tau$ (\emph{filter}):
	%% denoting the set of all traces contained in $\tau$, when they are deprived af all events that do not match $\eventTy$ (theoretically, this operator can also be derived from the others).
\end{itemize}
Other useful derivable operators are available, including the standard postfix operators
\lstinline{?}, \lstinline{+} and \lstinline{*}, borrowed from regular expressions,  the constant \lstinline{all}, which denotes the universe of all traces,
and the  conditional filter operator \lstinline{_ >> _ : _}.
%% which denotes the set of all
%% traces verifying $\te_1$ when only the events matching $\eventTy$ are kept, and
%% $\te_2$ when the events matching $\eventTy$ are filtered out.

%Trace expressions are regular terms (a.k.a. cyclic) \cite{Courcelle83}, thus there is no need for an explicit recursion operator.
The formal semantics of trace expressions is defined in terms of a labeled transition system \cite{RML2021}.

As a very simple example, the specification \lstinline{Main} 
\begin{figure}[h]
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
remove(hash_id) matches {event:'func_post', targetId:hash_id, name:'remove', res:true};
add(hash_id) matches {event:'func_post', targetId:hash_id, name:'add', res:true};

Main = add(42)* remove(42) all;
\end{lstlisting}
\caption{Example of specification.}\label{list:example}
\end{figure}
defines the set of event traces consisting of zero or more calls to method \lstinline{add} on target 42 with returned value \lstinline{true},
followed by a call to method \lstinline{remove} on the same target 42 with returned value \lstinline{true} and by any other trace.

\paragraph{Parametric Specifications}
The expression \lstinline{open(fdesc) write(fdesc)* close(fdesc)} can only verify the correct use of a single file;
the parametric layer of \rml provides a \lstinline{let} construct \cite{AnconaFM17} for declaring variables and delimiting their scope,
to control their dynamic instantiation through event matching.
With such an abstraction and the shuffle operator, it is possible to write a \emph{parametric} specification
for monitoring the access to an arbitrary number of files:
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
Main = {let fdesc; open(fdesc) (write(fdesc)* close(fdesc)  | Main)};
\end{lstlisting}
When the first event matches \lstinline{open(fdesc)}, a substitution for variable 
\lstinline{fdesc} is computed, depending from the returned value of \lstinline{fs.openSync}, and such a substitution is applied
to the rest of the specification.
In this way, the two occurrences of \lstinline{fdesc} on the left operand of the shuffle are correctly
instantiated, while the substitution does not affect the right operand, consisting of the recursive
use of \lstinline{Main}, because the nested \lstinline{let} construct allows the declaration of fresh
variables to mask the previously instantiated variables. As a consequence, the
next call to \lstinline{fs.openSync} is allowed to pass a different file name and return a
different file descriptor, because the corresponding event type pattern \lstinline{open(fdesc)}
is not instantiated yet.

%% At this point the shuffle operator is crucial\footnote{In order for the shuffle to work, we assume that every \(\opent\) operation always gives a fresh file descriptor, which can be reasonably assumed to be ensured by the operating system.}: following events are allowed to belong either to \(\tau\) (operations on new files, in the correct order) or to \(\tau'\{\avar{fd}\mapsto x\}\) (note the substitution!) were further operations on \(x\) will be checked.

\paragraph{Generic Specifications}
The most abstract layer of \rml provides support for \emph{generic} specifications,
which enhance modularity, offer more opportunities for reuse and increase the expressive power of \rml with the conditional expression.
For instance, the specification \lstinline{Main} defined above
can be generalized as follows to make it reusable in other specifications:
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
File<fdesc> = write(fdesc)* close(fdesc); // only write allowed before closing 
Main = {let fdesc; open(fdesc) (File<fdesc>  | Main)};
\end{lstlisting}
If one would like to change the specification of the allowed operations on the files to be monitored, then only the definition
of the parametric specification \lstinline{File<fdesc>} needs to be redefined:
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
...
chmod(fd) matches {event:'func_pre', name:'fs.fchmodSync', args:[fd,_]};

File<fdesc> = chmod(fdesc)? write(fdesc)* close(fdesc); // chmod allowed but only before writing
Main = {let fdesc; open(fdesc) (File<fdesc>  | Main)}; // Main specification unchanged
\end{lstlisting}
Recursion together with the conditional expression are used to define more expressive generic specifications:
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
Repeat<n> = if (n>0) eventType Repeat<n-1> else empty;
\end{lstlisting}
The generic specification \lstinline{Repeat<$n$>} defines all traces of length $n$ where all events match
the event type pattern \lstinline{eventType}.
